#' Build directed graph
#'
#' Builds a de-Brujin-Graph via left-right k-1 overlaps
#'
#' @param nodes A vector of nodes (generated by get_nodes.R)
#' @importFrom magrittr "%>%"
#' @export
#=======================================
get_graph = function(nodes){

  nodesLeftRight = lapply(nodes, get_subK)
  find_edges(nodesLeftRight)

}

#---------------------------------------
get_subK = function(node){
  "takes an array of nodes and outputs a list of left and right k-1-mers"
  lenNode = nchar(node)
  left = substr(node, start = 1, stop = lenNode -1)
  right = substr(node, start = 2, stop = lenNode)
  return( c(left, right) )
}

#---------------------------------------
find_edges = function(subK.ls){
  "Takes a list of left/right k-1-mers of nodes and determines their overlaps. Then Builds a list of edges per node (innodes and outnodes)
  source subsetting with sapply: https://stackoverflow.com/questions/44176908/r-list-get-first-item-of-each-element
  source appending per list: https://stackoverflow.com/questions/9950144/access-lapply-index-names-inside-fun"
  kLeft = sapply(subK.ls, "[[", 1)
  kRight= sapply(subK.ls, "[[", 2)

  ## return overlaps between right and left k-1mers. Then replace empty with NA. important for later!
  outnode = lapply(kRight, function(x) which(kLeft %in% x)) #%>%
    #lapply(., function(x) replace(x, length(x) == 0, NA))
    # innode = c(1:length(outnode))
  innode = lapply(kLeft, function(x) which(kRight %in% x))  #%>%
    #lapply(., function(x) replace(x, length(x) == 0, NA))

  # combine innode and outnode. "Loop" through the indexes to target query list elements. then rename each list element after the corresponding node.
  lapply(seq_along(innode),
         function(i) list(innodes = innode[[i]], outnodes = outnode[[i]])) %>%
    setNames(., seq_along(.))
}
